# ムーブセマンティクス

## コピーとムーブ

次のコードは大規模な配列 `x` を用意し、 `y` にディープコピーしています。そして、それ以降 `x` は利用していません。

```cpp
{
    std::vector<int> x(1000000);
    std::vector<int> y = x;

    // 以降 x は利用しない
}
```

ディープコピーの場合、`y` を生成するのに `x` と同程度のメモリ領域を確保する必要があります。
これはコストの面ではかなりの無駄があります。

次のコードは `x` を `y` にシャローコピーした後に、 `x` に `nullptr` を代入しています。

```cpp
{
    std::vector<int>* x = new std::vector<int>(1000000);
    std::vector<int>* y = x;
    x = nullptr;

    // 以降 x は利用しない
}
```

これがムーブの根底にある考え方で、
ポインタの付け替えだけで、あたかも `x` が `y`　に移動しているような挙動を実現出来ているため、
ディープコピーのときよりもコストの面で有利です。

しかし、ポインタの操作を伴う実装になるため、プログラマが細心の注意を払って実装しないと、
ムーブの仕組みが実現できなくなるというリスクも存在します。

そこで、 C++11からはムーブの考え方をテクニックとしてでは無く、言語仕様として実現する仕組みが取り入れられました。
これがムーブセマンティクスと呼ばれているものです。

## 右辺値と左辺値

ムーブセマンティクスを理解するために、右辺値と左辺値について理解する必要があります。

- 左辺値: 基本的にそのスコープの間生き続ける名前付きのオブジェクト
- 右辺値: リテラルや関数が返す一時オブジェクトのようなその瞬間に破棄されて不要になるもの

```cpp
{
    int x = 300; // x は左辺値。300 のようなリテラルは右辺値。
    int y = function(); // y は左辺値。関数 function が返す一時オブジェクトは右辺値。
    int z = x; // z と x は左辺値。
}
```

右辺値は左辺値へ格納したら必要無くなるので、右辺値にはムーブの考え方が適用できることがわかります。
C++11 以降、コンパイラはこの考え方を認識し、ムーブを実現してくれるようになりました。

## std::move

次の例では、`x` はコンパイラからしてみると左辺値なので、ムーブセマンティクスが実現できません。

```cpp
{
    std::vector<int> x(1000000);
    std::vector<int> y = x; // y と x は左辺値

    // 以降 x は利用しない
}
```

そこで、左辺値を右辺値にキャストする `std::move` を使います。
`x` を右辺値にキャストすることで、ムーブセマンティクスが適用できるようにコンパイラに促しています。

```cpp
{
    std::vector<int> x(1000000);
    std::vector<int> y = std::move(x); // std::move で x を右辺値にキャスト

    // 以降、xは利用しない
}
```

<!-- MEMO: 右辺値参照/ユニヴァーサル参照には触れない -->
<!-- MEMO: またムーブセマンティクスでは所有権の移動も実現しています。 -->
