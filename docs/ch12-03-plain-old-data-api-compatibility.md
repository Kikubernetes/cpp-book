# POD の API 互換性

C と C++ でヘッダファイルを共有して、
同じ型宣言を使用するには API 互換性が必要です。
POD であれば ABI 互換性は保証されますが、 API 互換性は保証されません。

POD にする場合には API 互換性もあるように定義しましょう。

## C には存在しない C++ の機能

C に存在しない機能を使用していると API 互換性はありません。
C に存在しない機能の一例として次のものがあります。

- クラス
- 名前空間
- テンプレート
- C++ の標準ヘッダファイル

### クラス

C にはクラスはありませんが構造体はあります。
そのため POD の型はクラスではなく構造体にするのが一般的です。

C の構造体はメンバ変数をもつ以外の機能はなく、以下の機能は使用できません。

- メンバ関数
- 継承
- メンバ変数に対するアクセス指定子

API 互換性を保つためには、
これらの機能を一切使用しないで構造体を定義するとよいです。

```cpp
struct Sample {
    int i;
    double d;
};
```

### C++ の標準ヘッダファイル

C++ の標準ヘッダファイルは C では使用できませんが、
C の標準ヘッダファイルは C++ でも使用できます。

C の標準ヘッダファイルに対して、
C++ では先頭に `c` をつけて拡張子を除いたものが用意されています。
たとえば C の標準ヘッダファイル `<stdint.h>` に対して
C++ の標準ヘッダファイル `<cstdint>` があります。

通常 C++ では C++ の標準ヘッダファイルを使用するのが望ましいのですが、
C の標準ヘッダファイルを使用することができます。
この2つの違いは C++ のものは `std` 名前空間に属するようになることです。

API 互換性を保つためには、 C の標準ヘッダファイルを使用します。

```cpp
#include <stdint.h>

struct FundamentalTypes {
    int16_t i;
    double d;
};
```

## C++ には存在しない C の機能

C++ は C と高い互換性がありますが、完全上位互換ではありません。
C++ に存在しない機能を使用していると API 互換性はありません。
C++11 は [C99] というバージョンの C の機能を概ね取り込んでいますが、
すべての機能を取り込んでいる訳ではありません。

[C99]: https://ja.wikipedia.org/wiki/C99

たとえば C99 には複合リテラルという機能がありますが C++ では使用できません。

```c hl_lines="9 10"
int Sum(const int v[], int n) {
    int sum = 0;
    for (int i = 0; i < n; ++i) {
        sum += v[i];
    }
    return sum;
}

// 複合リテラルによる配列の生成
int sum = Sum((int[]){1, 2, 3, 4, 5}, 5);
```

同様の処理を C++ で行うには `std::array` などを使用する必要があります。

```cpp
int sum = Sum(std::array<int, 5>({1, 2, 3, 4, 5}).data(), 5);
```

詳細は
[複合リテラル - cppreference.com][cppreference_compound_literal]
を参照してください。

[cppreference_compound_literal]: https://ja.cppreference.com/w/c/language/compound_literal
