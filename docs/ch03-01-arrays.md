# 配列

配列は同一の型を持つ複数の値をまとめて管理するための型です。
使い方は次のとおりです。

```cpp
int x[5] = {0, 1, 2, 3, 4};
```

これで 5 要素の値を持つ配列が宣言されます。

## 要素参照

配列の要素を参照するには配列の何番目の要素なのかを指定します。
数えの始まりは 0 からになります。

```cpp
int x[5] = {0, 1, 2, 3, 4};
int y = x[2];  // 2
```

## 初期化のバリエーション

配列の宣言と同時に要素を設定する場合は要素数の指定が省略できます。

```cpp
int x[] = {0, 1, 2, 3, 4, 5};
```

配列の宣言後に要素を設定する場合は要素数の指定が必要です。

```cpp
int x[5];

x[0] = 0;
x[1] = 1;
x[2] = 2;
x[3] = 3;
x[4] = 4;
```

要素数に比べて設定した要素の個数が少ない場合は残りの要素がゼロで初期化されます。

```cpp
int x[5] = {0, 1, 2};  // x[3], x[4] はゼロで初期化
```

要素を全く指定しないとすべての要素がゼロで初期化されます。

```cpp
int x[5] = {};
```

これが一番手軽な初期化方法です。

## 配列とポインタ

配列を参照する時に、 `[]` を省略すると、配列の先頭を指し示すポインタが取得できます。
先頭のポインタにインデックスを足すことで、それぞれの要素に対応したポインタが取得できます。

```cpp
#include <iostream>

int x[] = {2, 4, 6, 8, 10};
int* p = x;
std::cout << *p << std::endl;        // 2
std::cout << *(p + 1) << std::endl;  // 4
std::cout << *(p + 2) << std::endl;  // 6
std::cout << *(p + 3) << std::endl;  // 8
std::cout << *(p + 4) << std::endl;  // 10
```

## 関数に配列を渡す

配列も通常の変数同様、関数に渡すことが出来ます。

```cpp
#include <iostream>

void PrintArray(int x[5]) {
    for (int i = 0; i < 5; ++i) {
        std::cout << x[i] << std::endl;
    }
}

int main() {
    int x[5] = {0, 1, 2, 3, 4};

    PrintArray(x);

    return 0;
}
```

しかし、上記の例だと要素数が `5` 以外の配列を扱いたい時に不便です。
そのため、関数に配列を渡す場合は、配列の先頭ポインタと要素数をセットで渡すことが多いです。

```cpp
#include <iostream>

void PrintArray(int* x, int num) {
    for (int i = 0; i < num; ++i) {
        std::cout << x[i] << std::endl;
    }
}

int main() {
    int num = 5;
    int x[num] = {0, 1, 2, 3, 4};

    PrintArray(x, num);

    return 0;
}
```

## std::array

より高機能な配列を使用したい場合は `std::array` を使用します。

```cpp
#include <array>

std::array<int, 5> x = {0, 1, 2, 3, 4};
```

`x` は要素数が 5 であるような `int` の配列になります。
`std::array` を使用するには `<array>` のインクルードが必要です。
要素参照は通常の配列と同じようにできます。

```cpp
x[2] = 10;
```

`x.size()` とすると要素数が取得できます。

```cpp
auto size = x.size();  // 5
```

通常の配列からは要素数を取得することはできないため、
配列と要素数を保存した変数の2つを持ち回す必要があります。
`std::array` を使えばそれらをひとまとめにして扱えるので便利です。
